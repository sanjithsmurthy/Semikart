import 'package:flutter/material.dart';
import 'dart:async'; // Import for Future used in WillPopScope

import 'Components/common/header.dart';
import 'Components/common/hamburger.dart';
import 'app_navigator.dart'; // Import the central navigator setup

// TODO: Replace ValueNotifier with a proper state management solution (e.g., Riverpod) for cart count
final cartItemCountProvider = ValueNotifier<int>(0); // Temporary placeholder - Replace with Riverpod

class BaseScaffold extends StatefulWidget {
  final int initialIndex;
  final ValueChanged<int>? onNavigationItemSelected;

  // Static key to access the state, primarily used by AppNavigator
  static final GlobalKey<_BaseScaffoldState> navigatorKey = GlobalKey<_BaseScaffoldState>();

  const BaseScaffold({
    // Use ValueKey for better widget identification if needed, otherwise super.key is fine
    super.key, // Using super.key is standard practice now
    this.initialIndex = 0,
    this.onNavigationItemSelected,
  });

  @override
  State<BaseScaffold> createState() => _BaseScaffoldState();
}

class _BaseScaffoldState extends State<BaseScaffold> {
  late int _selectedIndex;
  DateTime? _lastPressedAt; // For double-tap-to-exit logic

  // Pages are now generated by AppNavigator static methods, ensuring each tab has its own Navigator
  final List<Widget> _pages = [
    AppNavigator.homeNavigator(),
    AppNavigator.productsNavigator(),
    AppNavigator.searchNavigator(), // Assuming AppNavigator provides this
    AppNavigator.cartNavigator(),
    AppNavigator.profileNavigator(), // Assuming AppNavigator provides this
  ];

  @override
  void initState() {
    super.initState();
    _selectedIndex = widget.initialIndex;
    // TODO: Initialize cart item count listener here if using a provider
    // Example using Riverpod (assuming a cartProvider exists):
    // WidgetsBinding.instance.addPostFrameCallback((_) {
    //   ref.read(cartProvider.notifier).loadCart(); // Load initial cart state
    // });
    // Listen to the cart count provider (temporary ValueNotifier example)
    cartItemCountProvider.addListener(_updateCartBadge);
  }

  @override
  void dispose() {
    // Clean up listener to prevent memory leaks
    cartItemCountProvider.removeListener(_updateCartBadge);
    super.dispose();
  }

  // Callback for the ValueNotifier to trigger a rebuild if needed (though ValueListenableBuilder handles UI)
  void _updateCartBadge() {
    // If the badge logic needed more complex state updates, you could use setState here.
    // For ValueListenableBuilder, this listener might just be for logging or side effects.
    // print("Cart count updated: ${cartItemCountProvider.value}");
  }


  // Method to switch tabs in the BottomNavigationBar
  void switchToTab(int index) {
    // Check if the index is valid and different from the current index
    if (index >= 0 && index < _pages.length && _selectedIndex != index) {
      // Pop to the first route in the *current* tab's navigator *before* switching tabs
      _popToFirstRouteInCurrentTab();
      // Update the state to change the selected tab
      setState(() {
        _selectedIndex = index;
      });
      // Notify the parent widget (if any) via the callback
      widget.onNavigationItemSelected?.call(index);
    } else if (_selectedIndex == index) {
      // If the user taps the *already selected* tab, pop its navigator to the first route
      _popToFirstRouteInCurrentTab();
    }
  }

  // Pops the navigator stack of the currently selected tab back to its initial route
  void _popToFirstRouteInCurrentTab() {
    final currentNavigatorKey = getNavigatorKeyForIndex(_selectedIndex);
    // Check if the navigator state exists and can pop
    if (currentNavigatorKey?.currentState?.canPop() ?? false) {
      // Pop until the first route (predicate returns true for the first route)
      currentNavigatorKey!.currentState!.popUntil((route) => route.isFirst);
    }
  }

  // Helper to get the correct Navigator's GlobalKey based on the tab index
  GlobalKey<NavigatorState>? getNavigatorKeyForIndex(int index) {
    switch (index) {
      case 0:
        return AppNavigator.homeNavKey;
      case 1:
        return AppNavigator.productsNavKey;
      case 2:
        return AppNavigator.searchNavKey; // Use the key from AppNavigator
      case 3:
        return AppNavigator.cartNavKey;
      case 4:
        return AppNavigator.profileNavKey; // Use the key from AppNavigator
      default:
        return null; // Should not happen with valid indices
    }
  }

  // Determines the title for the AppBar based on the selected tab index
  String? _getTitle(int index) {
    switch (index) {
      // No title for Home (index 0) by default, Header shows logo/search
      case 1:
        return 'Products';
      case 2:
        return 'Search'; // Title for the search tab itself
      case 3:
        return 'Your Cart';
      case 4:
        return 'Profile';
      default:
        return null; // Default case, should ideally not be hit
    }
  }

  // Handles the Android back button press using WillPopScope
  Future<bool> _handleWillPop() async {
    final currentNavKey = getNavigatorKeyForIndex(_selectedIndex);
    final navState = currentNavKey?.currentState;

    // 1. Try popping the current nested navigator first
    if (navState != null && navState.canPop()) {
      navState.pop();
      // Update the UI (e.g., Header back button visibility might change)
      setState(() {});
      return false; // Prevent default back behavior (closing app/popping BaseScaffold)
    }

    // 2. If not on the Home tab (index 0) and cannot pop further, switch to the Home tab
    if (_selectedIndex != 0) {
      switchToTab(0); // Use the switchToTab method to handle state change and callbacks
      return false; // Prevent default back behavior
    }

    // 3. If on the Home tab and cannot pop further, handle double-tap-to-exit
    final now = DateTime.now();
    // Check if last press was null or more than 2 seconds ago
    if (_lastPressedAt == null || now.difference(_lastPressedAt!) > const Duration(seconds: 2)) {
      _lastPressedAt = now;
      _showExitPromptSnackbar(); // Show "Press back again to exit" message
      return false; // Prevent app exit on the first tap
    } else {
      // If second tap is within 2 seconds, allow app exit
      return true;
    }
  }

  // Shows a SnackBar prompting the user to press back again to exit
  void _showExitPromptSnackbar() {
    // Ensure the widget is still mounted before showing the SnackBar
    if (!mounted) return;
    // Remove any existing SnackBars first to avoid stacking
    ScaffoldMessenger.of(context).removeCurrentSnackBar();
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: const Text(
          "Press back again to exit",
          style: TextStyle(
            color: Colors.black, // Consider using theme text color
            fontWeight: FontWeight.bold,
          ),
          textAlign: TextAlign.center,
        ),
        duration: const Duration(seconds: 2), // How long the SnackBar is visible
        backgroundColor: Colors.white.withOpacity(0.9), // Semi-transparent white background
        behavior: SnackBarBehavior.floating, // Floating appearance
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(10), // Rounded corners
        ),
        // Adjust margin for centering and spacing from edges/bottom nav
        margin: const EdgeInsets.only(bottom: 80, left: 60, right: 60), // Increased bottom margin
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12), // Internal padding
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    // Determine if the nested navigator for the current tab can pop
    final bool canPopNested = getNavigatorKeyForIndex(_selectedIndex)?.currentState?.canPop() ?? false;
    // Show the Header's back button if the nested navigator can pop OR if not on the home tab
    final bool showHeaderBackButton = canPopNested || _selectedIndex != 0;

    return WillPopScope(
      onWillPop: _handleWillPop, // Intercept back button presses
      child: Scaffold(
        // Prevent keyboard from resizing the scaffold body unnecessarily
        resizeToAvoidBottomInset: false,
        appBar: Header(
          showBackButton: showHeaderBackButton,
          title: _getTitle(_selectedIndex), // Get title based on current tab
          onBackPressed: () {
            final currentNavKey = getNavigatorKeyForIndex(_selectedIndex);
            final navState = currentNavKey?.currentState;

            // If the current nested navigator can pop, pop it
            if (navState != null && navState.canPop()) {
              navState.pop();
              // Update UI after pop if needed (e.g., Header back button visibility)
              setState(() {});
            }
            // Otherwise, if not on the home tab, switch to the home tab
            else if (_selectedIndex != 0) {
              switchToTab(0);
            }
            // If on the home tab and cannot pop, do nothing (WillPopScope handles exit)
          },
          // When the logo is tapped, pop all navigators to root and switch to home
          onLogoTap: () {
            // Pop all tab navigators to their first route
            getNavigatorKeyForIndex(0)?.currentState?.popUntil((route) => route.isFirst);
            getNavigatorKeyForIndex(1)?.currentState?.popUntil((route) => route.isFirst);
            getNavigatorKeyForIndex(2)?.currentState?.popUntil((route) => route.isFirst);
            getNavigatorKeyForIndex(3)?.currentState?.popUntil((route) => route.isFirst);
            getNavigatorKeyForIndex(4)?.currentState?.popUntil((route) => route.isFirst);
            // Switch to the home tab
            switchToTab(0);
          },
        ),
        drawer: const HamburgerMenu(), // Side drawer
        body: IndexedStack(
          index: _selectedIndex,
          children: _pages, // Display the widget corresponding to the selected index
        ),
        bottomNavigationBar: BottomNavigationBar(
          type: BottomNavigationBarType.fixed, // Ensures all items are visible and labels shown
          currentIndex: _selectedIndex,
          selectedItemColor: const Color(0xFFA51414), // Theme primary color for selected item
          unselectedItemColor: Colors.grey.shade600, // Slightly darker grey for unselected
          backgroundColor: Colors.white, // Standard white background
          selectedFontSize: 12, // Slightly smaller font size
          unselectedFontSize: 12,
          onTap: switchToTab, // Use the centralized tab switching method
          items: [
            _buildNavItem(Icons.home_outlined, Icons.home, "Home", 0), // Use outlined/filled icons
            _buildNavItem(Icons.inventory_2_outlined, Icons.inventory_2, "Products", 1),
            _buildNavItem(Icons.search_outlined, Icons.search, "Search", 2),
            _buildCartNavItem(Icons.shopping_cart_outlined, Icons.shopping_cart, "Cart", 3), // Use the specific cart item builder
            _buildNavItem(Icons.person_outline, Icons.person, "Profile", 4),
          ],
        ),
      ),
    );
  }

  // Helper to build standard navigation items with outlined/filled icons based on selection
  BottomNavigationBarItem _buildNavItem(IconData outlinedIcon, IconData filledIcon, String label, int index) {
    return BottomNavigationBarItem(
      icon: Icon(_selectedIndex == index ? filledIcon : outlinedIcon),
      label: label,
    );
  }

  // Helper to build the cart navigation item with a badge
  // TODO: Replace ValueListenableBuilder with Consumer/Selector from Riverpod for better state management
  BottomNavigationBarItem _buildCartNavItem(IconData outlinedIcon, IconData filledIcon, String label, int index) {
    // final cartItemCountProvider = ValueNotifier<int>(2); // Temporary placeholder - REMOVE THIS

    return BottomNavigationBarItem(
      icon: Stack(
        clipBehavior: Clip.none, // Allow badge to overflow icon bounds
        children: [
          Icon(
            _selectedIndex == index ? filledIcon : outlinedIcon, // Use filled/outlined based on selection
            size: 28, // Slightly adjusted size
          ),
          ValueListenableBuilder<int>( // Replace with Consumer/Selector listening to Riverpod provider
            valueListenable: cartItemCountProvider, // Use the actual provider instance
            builder: (context, count, child) {
              // Show badge only if count > 0
              if (count > 0) {
                return Positioned(
                  right: -6, // Adjust position for badge
                  top: -4,   // Adjust position for badge
                  child: Container(
                    padding: const EdgeInsets.all(2),
                    decoration: const BoxDecoration(
                      color: Color(0xFFA51414), // Badge background color (theme primary)
                      shape: BoxShape.circle,
                    ),
                    constraints: const BoxConstraints(
                      minWidth: 16, // Slightly smaller badge
                      minHeight: 16,
                    ),
                    child: Text(
                      count > 9 ? '9+' : count.toString(), // Show '9+' if count exceeds 9
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 10, // Smaller font size for badge
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ),
                );
              }
              // Return an empty container if count is 0
              return const SizedBox.shrink();
            },
          ),
        ],
      ),
      label: label,
    );
  }
}
